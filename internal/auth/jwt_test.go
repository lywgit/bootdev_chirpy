package auth

import (
	"fmt"
	"strings"
	"testing"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
)

// TestMakeJWT and TestValidateJWT are modified from LLM's suggestion

func TestMakeJWT(t *testing.T) {
	tests := []struct {
		name        string
		userID      uuid.UUID
		secret      string
		expiresIn   time.Duration
		expectError bool
	}{
		{
			name:        "Successful token generation",
			userID:      uuid.New(),
			secret:      "test-secret-make-123",
			expiresIn:   time.Hour,
			expectError: false,
		},
		{
			name:        "Empty secret should not generate valid token",
			userID:      uuid.New(),
			secret:      "",
			expiresIn:   time.Hour,
			expectError: true, // expect fail
		},
		{
			name:        "Zero expiration time",
			userID:      uuid.New(),
			secret:      "test-secret-make-456",
			expiresIn:   0, // expire immediately
			expectError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tokenString, err := MakeJWT(tt.userID, tt.secret, tt.expiresIn)

			if tt.expectError {
				if err == nil {
					t.Errorf("Expected an error for %s, but got none", tt.name)
				}
				return
			}

			if err != nil {
				t.Fatalf("Unexpected error for %s: %v", tt.name, err)
			}
			if tokenString == "" {
				t.Errorf("Expected non-empty token string, but got empty for %s", tt.name)
			}
			// Parse and check claims
			keyfunc := func(token *jwt.Token) (any, error) {
				if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
					return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
				}
				return []byte(tt.secret), nil
			}
			parsedToken, parseErr := jwt.ParseWithClaims(tokenString, &jwt.RegisteredClaims{}, keyfunc)
			if parseErr != nil {
				// special case of 0 expiration time
				if tt.expiresIn == 0 && strings.Contains(parseErr.Error(), "token is expired") {
					return
				}
				t.Fatalf("Failed to parse token generated by MakeJWT for %s: %v", tt.name, parseErr)
			}
			if !parsedToken.Valid {
				t.Fatalf("Generated token is not valid for %s", tt.name)
			}

			claims, ok := parsedToken.Claims.(*jwt.RegisteredClaims)
			if !ok {
				t.Fatalf("Failed to cast claims to *jwt.RegisteredClaims for %s", tt.name)
			}

			// Check Subject (userID)
			if claims.Subject != tt.userID.String() {
				t.Errorf("Expected Subject %s, got %s for %s", tt.userID.String(), claims.Subject, tt.name)
			}

			// Check expiration time is approximately correct
			expectedExpiry := time.Now().Add(tt.expiresIn)
			if claims.ExpiresAt == nil || claims.ExpiresAt.Before(expectedExpiry.Add(-5*time.Second)) || claims.ExpiresAt.After(expectedExpiry.Add(5*time.Second)) {
				t.Errorf("Expected expiration around %v, got %v for %s", expectedExpiry.Truncate(time.Second), claims.ExpiresAt.Time.Truncate(time.Second), tt.name)
			}
		})
	}
}

func TestValidateJWT(t *testing.T) {
	// -- initialize variables for test cases
	validSecret := "my-super-secure-validation-secret-for-tests"
	testUserID := uuid.New()
	// a valid token
	validToken, err := MakeJWT(testUserID, validSecret, time.Minute)
	if err != nil {
		t.Fatalf("Failed to make valid token for testing: %v", err)
	}
	// an expring token
	expiringUserID := uuid.New()
	expiringToken, err := MakeJWT(expiringUserID, validSecret, 1*time.Millisecond)
	if err != nil {
		t.Fatalf("Failed to make expiring token for testing: %v", err)
	}
	// a token with incorrect UUID (the naked block is to keep things clean)
	nonUUIDSubjectToken := ""
	{
		claims := jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			Subject:   "not-a-uuid-string", // simulate incorrect uuid format
		}
		token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
		nonUUIDSubjectToken, err = token.SignedString([]byte(validSecret))
		if err != nil {
			t.Fatalf("Failed to make non-UUID subject token for testing: %v", err)
		}
	}
	// -- define test cases
	tests := []struct {
		name           string
		tokenString    string
		secret         string
		expectedError  string // expected error message in string
		expectedUserID uuid.UUID
	}{
		{
			name:           "Valid token and secret",
			tokenString:    validToken,
			secret:         validSecret,
			expectedError:  "",
			expectedUserID: testUserID,
		},
		{
			name:           "Expired token",
			tokenString:    expiringToken,
			secret:         validSecret,
			expectedError:  "token is expired",
			expectedUserID: uuid.Nil,
		},
		{
			name:           "Invalid secret",
			tokenString:    validToken,
			secret:         "wrong-secret-for-validation",
			expectedError:  "signature is invalid",
			expectedUserID: uuid.Nil,
		},
		{
			name:           "Malformed token (invalid base64 or structure)",
			tokenString:    "malformed.token.string",
			secret:         validSecret,
			expectedError:  "token is malformed",
			expectedUserID: uuid.Nil,
		},
		{
			name:           "Empty token string",
			tokenString:    "",
			secret:         validSecret,
			expectedError:  "token is malformed",
			expectedUserID: uuid.Nil,
		},
		{
			name:           "Subject is not a valid UUID",
			tokenString:    nonUUIDSubjectToken,
			secret:         validSecret,
			expectedError:  "invalid UUID",
			expectedUserID: uuid.Nil,
		},
	}

	// wait for token to really expire
	time.Sleep(100 * time.Millisecond)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			actualUserID, err := ValidateJWT(tt.tokenString, tt.secret)

			if tt.expectedError != "" {
				if err == nil {
					t.Errorf("Expected error containing '%s' for %s, but got none", tt.expectedError, tt.name)
				} else if !strings.Contains(err.Error(), tt.expectedError) {
					t.Errorf("Expected error containing '%s' for %s, but got '%v'", tt.expectedError, tt.name, err)
				}
				if actualUserID != uuid.Nil {
					t.Errorf("Expected uuid.Nil for UserID on error, but got %s for %s", actualUserID, tt.name)
				}
			} else {
				if err != nil {
					t.Errorf("Unexpected error for %s: %v", tt.name, err)
				}
				if actualUserID != tt.expectedUserID {
					t.Errorf("Expected UserID %s, got %s for %s", tt.expectedUserID, actualUserID, tt.name)
				}
			}
		})
	}
}
